---
title: 基础算法 - 贪心法
tags:
  - '[I] 基础算法'
  - '[I] 贪心法'
categories:
  - Informatics
  - Notes
date: 2022-07-24 20:49:56
---


直面贪心——人类最原始的欲望

<!--more-->

## 引言

你在大街上走，在你 $10\mathrm{m}$ 的前方有 $10$ 大洋，在你 $100\mathrm{m}$ 的前方有 $100$ 大洋。此时你发现了 $10$ 大洋，还并未发现 $100$ 大洋，捡还是不捡？

说起来可能有些俗套，当然是捡啦，遇到 $100$ 大洋的时候再捡起来都带走啦~~（好像完美地诠释了何为贪心）~~。捡了又不亏，为何不捡，毕竟也没说只能捡一张，捡 $10$ 大洋的也不会对你要捡 $100$ 大洋造成影响，对吧？

没错，这就是贪心算法，Greedy Algorithm。

此时出题人有些不太愉悦，于是就加了一个限制条件：这一路上你只能带走一张。那还捡不捡？

当然是捡，之后要是遇到 $100$ 大洋再捡就是了，至于 $10$ 大洋不要也罢。

没错，这就是贪心算法的反悔操作。

## 贪心法

贪心法，如果我们每一步的决策互不相关，或者上一步更优可能让下一步最优解更优，那么就可以采取步步最优，以推出全局最优的策略。

这样如人性中最脆弱的欲望一般，只考虑当前情况下的最优解，毫无疑问是无法做长远打算的，如果当前决策对下一步决策可能有坏的影响——那就寄了。因此，贪心法一般需要证明，当然如果你 RP 够好闯出个不会证明的贪心正解那就也没啥好说的。

贪心法证明的常见手法如下。

  1. 排序思想，如果两项总的收益只与两项相对位置有关，或者说两项交换会导致收益变化，那么可以据此发掘排序顺序。
  2. 单步推进，如果在这一步最优解的基础上通过简单操作可以得到下一步的最优解，那么一定能够推出全局最优解。
  3. 反证法，如果不满足我们考虑的贪心条件，又是最优解，那就证明其有更优解，推出矛盾。
  4. 数学归纳法，首先很容易证明小规模的数据下贪心正确，再在假设规模为 $k$ 时成立的基础上证明 $k+1$ 成立。
  5. ……

贪心算法满足「最优子结构性质」，没错，就是动态规划那个，意思是问题的最优解包含子问题的最优解。因此，动态规划和贪心的题目总是那么相近。事实上，如果动态规划的转移撤销了限制条件，让一次决策不再影响之后的决策，比如说 0/1 背包问题每件物品的价值或者价格都为 $1$，那么就与贪心法在本质上互通了。

贪心算法的最优子结构就仅仅是问题本身，而动态规划的最优子结构更像加了限制条件的问题，因为一旦问题答案整合就难以寻出对转移有用的答案。动态规划将原本的问题答案拆分而不让其合并，以分别对以后有用。

因此，贪心法无法解决大多数代价收益不只为 $1$ 的问题，也无法解决转移中有限制条件参与的问题，这反映了贪心法的局限性。

## 例题分析

### T1 层次和中考物理持平的题

没错，中考物理就是指的[这道题](/others/Memories/Telling-a-Dream/#changhong9)。

题目说，有 $n$ 个数，要选取尽量多的数，满足这些数的总和不超过 $k$，求最多能选多少。

<br>

感受到了吧，这也是贪心。首先，我默认你已经知道了这道题怎么做。

至于为什么能这样做，假设我们选取到的最优方案中有比未选取的数大的，那么完全可以删除这个数而加入未选取的数，而还有可能能够加入未选取的多个数。因此存在更有方案，最优方案不成立。所以最优方案一定是选取较小的数。

### T2 Huffman 树之合并果子

来自 NOIP2004 提高组。

在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

<br>

这实际上是经典的 Huffman 树问题，将这 $n$ 个数作为叶结点的权值构造一棵二叉树，使得每个叶结点到根节点的路径长度乘上权值的乘积之和最小。显然，Huffman 树的非叶结点一定有两个子结点。

这是一棵 Huffman 树，不接受狡辩。非叶结点的权值为左右儿子结点权值之和。

{% asset_img huffman.png '"" "Huffman 树 图示"' %}

贪心策略是，每次寻找当前最小的两个数合并，生成两数的和，不断重复，直至剩下一个数为止。在 Huffman 树上，可以描述成对 $n$ 个数建 $n$ 棵大小为 $1$ 的数，每次合并根节点权值最小的两棵树，直到只剩一棵树为止。

贪心正确性证明，我们就来证明 Huffman 树吧，至于合并果子什么的不管了。

首先，我们能知道，权值最小的两个结点一定在树的最深层。~~（这不显然吗，要是不在最深层的话，让它和最深层的某个结点交换显然会得到更优解。）~~ 那么这权值最小的两个结点就可以拥有同一个父结点，毕竟父结点什么的并不重要，叶结点的权值和深度才有意义。我们将这两个结点的父结点的权值赋为两者之和。此时，我们发现，如果要取得最优解，那么就相当于这两者用它们的父结点代替，求得最优解，再加上这两者的权值和。

于是，显然就可以每次挑两个权值最小的结点合并成一个结点，重复以上步骤 $n-1$ 次。

对于合并果子这道实例，emmm 不用说了吧。

### T3 又双叒叕一道数学作业

对于 OIer 来说，见到「小 X 的数学老师给他留了一道作业……所以他只好来求助你」的次数恐怕不低于「假如你是李华，你的好友……写一封回信」。

没错，这次小 X 又双叒叕获得了一道数学作业。老师在黑板上写了一排数，每次能够擦去其中两个数 $a,b$，并将 $ab+1$ 新添加在数列中。老师想知道，最后只剩一个数时，这个数最大或最小是多少。这里我们考虑最大。

<br>

基本操作是，每次选取最小的两个数合并。

你聪明的小脑瓜陷入了沉思，好像在哪里见过的样子……我不说，猜对了我就告诉你。

好了好了，接下来要做的就是——证明它！PROVE IT!

沿用思路，但有所变化。我们能够知道，在这一排数中，我们必须首先合并最小的两个数。这一结论用反证法证明，假设在最优方案中，当前数列中最小的两个数为 $x,y$，$x$ 依次与 $a_1,a_2,a_3,...$ 合并，$y$ 与 $b_1,b_2,b_3,...$ 合并，之后两者再合并。以上所说的 $a_1,a_2,a_3,...,b_1,b_2,b_3,...$ 可能本就是起初就写上的数，也可能是合并生成的数，此时这个数的合并生成过程与我无关，我们只需要关心这个数一定是大于等于 $x,y$ 的。

然后，我们计算这个合并过程生成的数。

$$
\\begin{align}
S & =\\{[(xa_1+1)a_2+1]...a_n+1\\}\\{[(yb_1+1)b_2+1]...b_m+1\\}+1\\\\
  & =\\left[(xa_1+1)\\prod_{i=2}^{n}a_i+\\sum_{i=3}^{n}\\prod_{j=i}^{n}a_j+1\\right]\\left[(yb_1+1)\\prod_{i=2}^{m}b_i+\\sum_{i=3}^{m}\\prod_{j=i}^{m}b_j+1\\right]+1
\\end{align}
$$

令 $a=a_1$, $p=\prod\limits_{i=2}^{n}a_i$, $t=\sum\limits_{i=3}^{n}\prod\limits_{j=i}^{n}a_j+1$, $b=b_1$, $q=\prod\limits_{i=2}^{m}b_i$, $w=\sum\limits_{i=3}^{m}\prod\limits_{j=i}^{m}b_j+1$。

那么表达式就写成

$$
S=[(xa+1)p+t][(yb+1)q+w]+1
$$

由于我们只限定了 $x,y$ 是数列中最小的两个，也就是除 $x,y$ 以外的 $a_1,a_2,a_3,...,b_1,b_2,b_3,...$ 都大于等于 $x,y$，除此之外并未明确 $a,b$ 的顺序关系，那么 $a,b$ 是平等地位，同时与之相关的 $(p,q),(t,w)$ 也是平等地位。因此可以排序，令 $pw\leq qt$。

那么，设一个

$$
S'=[(xy+1)p+t][(ab+1)q+w]+1
$$

它表示在上述合并过程中，$y$ 和 $a$ 交换位置，所得出的另一种合并方案，最终所生成的数。

于是

$$
\\begin{align}
S-S'&=\\{[(xa+1)p+t][(yb+1)q+w]+1\\}-\\{[(xy+1)p+t][(ab+1)q+w]+1\\}\\\\
    &=(xap+p+t)(ybq+q+w)-(xyp+p+t)(abq+q+w)\\\\
    &=(xyabpq+xapq+xapw+ybpq+pq+pw+ybqt+qt+tw)\\\\
    &\\quad-(xyabpq+xypq+xypw+abpq+pq+pw+abqt+qt+tw)\\\\
    &=xapq-xypq+xapw-xypw+ybpq-abpq+ybqt-abqt\\\\
    &=(a-y)(xpq+xpw-bpq-bqt)\\\\
    &=(a-y)[(x-b)pq+xpw-bqt]
\\end{align}
$$

由既定条件可以得到

$$
\\begin{align}
y\\leq a&\\Rightarrow a-y\\geq 0,\\\\
x\\leq b,p>0,q>0&\\Rightarrow (x-b)pq\\leq 0,\\\\
x\\leq b,pw\\leq qt&\\Rightarrow xpw\\leq bqt
\\end{align}
$$

因此有 $S-S'=(a-y)[(x-b)pq+xpw-bqt]\leq 0$，也就是

$$
S\leq S'
$$

可能存在更优方案，且一定存在一种选取最小两数合并的方案与之同样优秀或者更优秀。

这与最优方案的描述不符，因此得到，一定存在一种方案，每次选取最小两数合并，得到最优方案。

沿用套路，每次选取最小两数合并过后，得到一个新的数列，再对这个新的数列求最优方案，得到最终的最优方案。

或许这道题还可以不严谨地合理猜测，因为在三个数的情况下，一定是先合并较小的两个数，因此合理外推，猜测 $n$ 个数的情况下也是先合并较小的两个数。

### T4 有点难度的过河问题

在漆黑的夜里，$N$ 位旅行者来到了一座狭窄而且没有护栏的桥边。如果不借助手电筒的话，大家是无论如何也不敢过桥去的。不幸的是，$N$ 个人一共只带了一只手电筒，而桥窄得只够让两个人同时过。如果各自单独过桥的话，$N$ 人所需要的时间已知；而如果两人同时过桥，所需要的时间就是走得比较慢的那个人单独行动时所需的时间。问题是，如何设计一个方案，让这 $N$ 人尽快过桥。

<br>

这道题其实也不算难，甚至连复杂的数学证明都用不上，接下来我们来讨论得出贪心策略的步骤。

首先，我们思考一个问题，在手电筒的每次来回中，除了最后一次有去无回，其余情况均是买的往返票。那么很明显，我们每次都需要送过去 $2$ 个人，又派 $1$ 个人将手电筒送回来。如此的话，我们才能在每次往返中往彼岸输送 $1$ 个人。

接下来，我们思考派回来的怎么选择。很明显，应该是彼岸目前存在的人中过河最快的一个人，这样不仅能减少送手电筒回来的时间，又能让此岸的人全部渡河到彼岸去的总时间可能更优。这个最快的人可能是这一次过河过来的，也可能是之前就在彼岸的。

然后，我们想一想，每次应该怎么派人过去。你聪明的小脑瓜灵光一现，想到既然每次都要浪费 $1$ 个人的时间将手电筒送回来，而这个人最终还回到了此岸，那么就尽量减少这个送回来的时间。很明显，要减少送回来的时间，就得是让 $1$ 个过河快的人送手电筒回来。而这样又衍生出一个问题，要让过河快的人回来，就得让过河快的人先过去，和 $1$ 个过河慢的人一起过去，未免有些浪费；但是我们可以让 $2$ 个过河慢的人一同过去，既然过河时间由过河慢的决定，那么另外 $1$ 个人只要不单独回来那么就可以尽量慢，这样又得让过河快的人先过去等着，让他过去等着就得有另 $1$ 个人陪他过去又送手电筒回来。这就产生了两种各具优劣的方案。

事实上，这样确实无法看出哪一种方案省更时间，那我们就到时候算就对了。对于 $1$ 个过河快的人陪同过河慢的人过河之后又送手电筒回来，这种情况在一次来回之间的变化只在于 $1$ 个慢的人过去了，而快的人毫无影响，于是这个快的人一定就要选最快的人。对于 $2$ 个过河慢的人一同过河，显然，不能让过河慢的人送手电筒回去，这样显然劣于第一种方案，但是我们可以先送 $1$ 个过河快的人过去等着，然后再把手电筒送回来，那么此时就得让最快的 $2$ 个人过去，其中 $1$ 个人回来，$2$ 个过河慢的人过去，另 $1$ 个人回来。

我们戏称一些词语。两个人一同过河，时间由较慢的人决定，我们称较快的人被较慢的人庇护过河。一轮或两轮往返过后，参与过河的人有人去到了彼岸，有人回到了此岸，我们称回到此岸的人护送去往彼岸的人过河。

这样是两种方案。然后我们考虑过河顺序。最快的 $2$ 个人一定是要最后最终过河（最终过河指过河过后不再回此岸）的，这样才能作为送手电筒回来的劳力，节省时间。而剩余人的顺序，对第一种方案来说是不影响的，毕竟它是靠最快的人不停护送别人过河；但对于第二种方案，我们在确定了最快的 $2$ 个人护送过后，需要考虑的就是慢的 $2$ 个人过河的时间，显然，如果确定了最慢的 $1$ 个人过河，另 $1$ 个人的过河时间不再产生影响，此时选取过河时间小于已确定的人的过河时间中过河最慢的一个人，能最优化总时间，因为这样让留在此岸的人过河总时间可能更优。也就是说，按过河时间排序，同时过河的 $2$ 个较慢的人应该是挨着的，又为了快速找出要过河的 $2$ 个人，因此从慢到快过河，这样数组末尾就是要过河的人。

于是我们得出一种方案，按过河时间排序，如果由 $2$ 个人护送当前留在此岸最慢的 $2$ 个人过河的时间相较于最快的人护送这 $2$ 个人过河的时间更优，那么优先考虑前者方案。否则，将最慢的人送过去过后，再考虑当前留在此岸的人中，最慢的人庇护次慢的人过河是否更优。最后处理一下图书情况，因为最快、次快、最慢、次慢的人至少得有 $4$ 个，如果小于 $4$ 个那么上述方案会失效。想一下，我们每次送走 $1$ 个或 $2$ 个人，那么最后剩下小于 $4$ 个人可能是 $2$ 个或 $3$ 个人。很明显，如果剩下 $2$ 个人，直接过河，如果剩下 $3$ 个人，由最快的人护送过河。

看来，就算是贪心算法，也是可以多种策略综合考虑的。

## 模型概述

灵感来自《信息学奥赛一本通·提高篇》。

### 选择不相交区间问题

选择尽量多的区间，使得这些区间两两没有公共部分。

做法是每次找左端点在已选区间的右端点以右的右端点坐标最小的一段区间。

正确性显然，在每次选择中，无论选哪一个都为总答案贡献 $1$，并无优劣之分，此时如果能选取右端点尽量靠左的区间，那么能够为之后的选择创造更优的环境，得到更优解，也可以用反证法证明。当然，如果每一段区间的选择有优劣之分，那就是动态规划的事情了。

#### T5 活动安排

评测链接：<https://loj.ac/p/10000>

设有 $n$ 个活动的集合 $E=\{1,2,...,n\}$，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动 $i$ 都有一个要求使用该资源的起始时间 $s_i$ 和一个结束时间 $f_i$，且 $s_i<f_i$。如果选择了活动 $i$，则它在时间区间 $[s_i,f_i)$ 内占用资源。若区间 $[s_i,f_i)$ 与区间 $[s_j,f_j)$ 不相交，则称活动 $i$ 与活动 $j$ 是相容的。也就是说，当 $f_i\leq s_j$ 或 $f_j\leq s_i$ 时，活动 $i$ 与活动 $j$ 相容。选择出由互相兼容的活动组成的最大集合。

```cpp
#include <cstdio>
#include <algorithm>

int n, Ans = 0;
struct ac
{
    int s, t;
} a[1005];

bool cmp(ac x, ac y)
{
    return x.t < y.t;
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d%d", &a[i].s, &a[i].t);

    std::sort(a + 1, a + n + 1, cmp);
    int t = 1, p = 1;
    while (p <= n)
    {
        ++Ans;
        t = a[p].t;
        while (a[p].s < t && p <= n) ++p;
    }
    printf("%d", Ans);
    return 0;
}
```

### 区间选点问题

有一定数量的要求，每个要求描述为在一段区间内存在至少一定数量的选点，这些要求的区间可能相交，现选取尽量少的点，满足所有要求。

做法是，将每个要求按区间右端点从小到大排序，处理到当前要求时，如果选点数量不足，就从区间尾部开始选未选择的点。

简单证明一下，处理到当前要求时，目前已经选择的方案是在满足前面所有要求的前提下对后面要求最优的方案，此刻当前区间必须要将不足的选点补齐，为了让这些选点更多地存在于多个区间内，从尾部开始选更容易被后面的区间包含。

#### T6 种树

评测链接：<ttps://loj.ac/p/10001>

现在我们国家开展新农村建设，农村的住房建设纳入了统一规划，统一建设，政府要求每一住户门口种些树。门口路边的地区被分割成块，并被编号成 $1...N$。每个部分为一个单位尺寸大小并最多可种一棵树。每个居民房子门前被指定了三个号码 $B,E,T$。这三个数表示该居民想在 $B$ 和 $E$ 之间最少种 $T$ 棵树。当然， $B\leq E$，居民必须记住在指定区不能种多于区域地块数的树，所以 $T\leq E-B+1$。居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量，尽量减少政府的支出。

（其实树状数组就是~~画蛇添脚脚（王之宏语）~~画龙点睛）

```cpp
#include <cstdio>
#include <algorithm>

int n, m;
bool f[30005];
namespace TA
{
    int c[30005];
    #define lowbit(x) (x & -x)
    void update(int x, int d)
    {
        while (x <= n)
        {
            c[x] += d;
            x += lowbit(x);
        }
    }
    int query(int x)
    {
        if (!x) return 0;
        return c[x] + query(x - lowbit(x));
    }
}
struct req
{
    int b, e, t;
} r[5005];
bool cmp(req x, req y)
{
    return x.e < y.e;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; ++i)
    {
        scanf("%d%d%d", &r[i].b, &r[i].e, &r[i].t);
        ++r[i].b;
        ++r[i].e;
    }

    std::sort(r + 1, r + m + 1, cmp);

    int Ans = 0;
    for (int i = 1; i <= m; ++i)
    {
        r[i].t -= TA::query(r[i].e) - TA::query(r[i].b - 1);
        if (r[i].t > 0)
        {
            int p = r[i].e;
            while (r[i].t)
            {
                while (f[p]) --p;
                f[p] = 1;
                TA::update(p, 1);
                --r[i].t;
                ++Ans;
            }
        }
    }
    printf("%d\n", Ans);
    return 0;
}
```

### 区间覆盖问题

在区间集合中选取一些区间，使得它们能够完全覆盖一段给定的区间。

每次选取左端点在已选区间能覆盖范围的右端点以左的所有区间中右端点最靠右的一个。

正确性显然，排序是必然的，问题只是按哪个端点排序。而在选择下一个端点的同时，首先要满足前提条件，然后取对之后选择更友善的一个。

#### T7 喷水装置

评测链接：<ttps://loj.ac/p/10002>

长 $L$ 米，宽 $W$ 米的草坪里装有 $n$ 个浇灌喷头。每个喷头都装在草坪中心线上（离两边各 $W/2$ 米）。我们知道每个喷头的位置（离草坪中心线端的距离），以及它能覆盖到的浇灌范围。

{% asset_img t7.gif '"" "喷水装置 题图"' %}

请问：如果要同时浇灌整块草坪，最少需要打开多少个喷头？

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>

int n, L, x, r;
double W, y;
struct range
{
    double b, e;
} a[15005];

bool cmp(range x, range y)
{
    return x.b < y.b;
}

int main()
{
    int T;
    scanf("%d", &T);
    for (int test = 1; test <= T; ++test)
    {
        scanf("%d%d%lf", &n, &L, &W);
        W = W / 2;
        for (int i = 1; i <= n; ++i)
        {
            scanf("%d%d", &x, &r);
            if (r * r <= W * W)
            {
                --i;
                --n;
                continue;
            }
            y = sqrt(r * r - W * W);
            a[i].b = x - y;
            a[i].e = x + y;
        }
        
        std::sort(a + 1, a + n + 1, cmp);
        
        int p = 1, Ans = 0;
        double ri = 0, est = 0;
        while (p <= n && ri < L)
        {
            if (a[p].b > ri)
            {
                printf("-1\n");
                goto Label;
            }
            while (a[p].b <= ri && p <= n) est = std::max(est, a[p].e), ++p;
            ++Ans;
            ri = est;
        }
        if (ri < L) printf("-1\n");
        else printf("%d\n", Ans);

    Label:
        continue;
    }
    return 0;
}
```

### 带限期和罚款的单位时间任务调度问题

有 $T$ 个单位时间，每个单位时间可以完成 $1$ 个任务。有 $N$ 个任务，第 $i$ 个任务需要在第 $t_i$ 个单位时间之前完成，如不能完成则有 $w_i$ 的罚款。求任务完成顺序的安排，使得罚款总额最小。

做法是，按照罚款从大到小排序，对于每个任务，如果在任务期限之前有单位时间空余，那么就选择最晚的一个单位时间完成该任务；否则接受罚款。

接下来证明该贪心策略。

这个贪心策略可以描述为，优先完成罚款较大的任务，而对于每个任务，尽量选择靠后的时间完成任务，因为对于限期更长的任务这样无所谓，对于限期更短的任务这样有可能减少对可用时间的占用。于是，我们要证明的，就是为什么要优先完成罚款较大的任务。

假设有任务 $i,j$，罚款、限期分别为 $w_i,t_i,w_j, t_j$，满足 $w_i>w_j$ 成立，按照贪心策略，任务 $i$ 是排在任务 $j$ 之前优先考虑的。

如果任务 $i,j$ 都能完成或都不能完成，那无妨。

如果任务 $i$ 不能完成而任务 $j$ 能够完成，那……一边凉快去吧。

如果 $t_i<t_j$，那没的说，任务 $i$ 更紧要还更值钱。

如果 $t_i>t_j$，采用排序思想证明。首先声明，在该贪心策略之下任务 $i$ 能够完成而任务 $j$ 不能够完成，这是这种情况的前提条件；另外，我们即使交换任务 $i,j$，在 $i,j$ 之间的任务安排时间都不会依照贪心策略而变化，原来是什么时间如今就是什么时间。假若完成任务 $i$ 的时间被安排在任务 $j$ 的时间期限之前，那么交换过后就会导致任务 $j$ 能够完成而任务 $i$ 不能够完成，就会导致罚款总额更大。假若完成任务 $i$ 的时间被安排下任务 $j$ 的时间期限之后，那么交换过后任务 $j$ 依旧不能被完成。因此，任务 $i$ 应该排在任务 $j$ 之前。

综上所述，罚款较大的任务应该优先完成。

#### T8 智力大冲浪

评测链接：<ttps://loj.ac/p/10004>

小伟报名参加中央电视台的智力大冲浪节目。本次挑战赛吸引了众多参赛者，主持人为了表彰大家的勇气，先奖励每个参赛者 $m$ 元。先不要太高兴！因为这些钱还不一定都是你的？！接下来主持人宣布了比赛规则：

首先，比赛时间分为 $n$ 个时段，它又给出了很多小游戏，每个小游戏都必须在规定期限 $t_i$ 前完成。如果一个游戏没能在规定期限前完成，则要从奖励费 $m$ 元中扣去一部分钱 $w_i$，$w_i$ 为自然数，不同的游戏扣去的钱是不一样的。当然，每个游戏本身都很简单，保证每个参赛者都能在一个时段内完成，而且都必须从整时段开始。主持人只是想考考每个参赛者如何安排组织自己做游戏的顺序。作为参赛者，小伟很想赢得冠军，当然更想赢取最多的钱！注意：比赛绝对不会让参赛者赔钱！

（我当时那么独流的吗，要借鉴并查集的思想来简化查询最后一个可用的单位时间）

```cpp
#include <cstdio>
#include <algorithm>

struct task
{
    int t, w;
} a[505];

bool cmp(task x, task y)
{
    return x.w > y.w;
}

int m, n;
int f[505];

int query(int x)
{
    if (f[x] == x) return x;
    return f[x] = query(f[x]);
}

int main()
{
    scanf("%d%d", &m, &n);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i].t);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i].w);

    std::sort(a + 1, a + n + 1, cmp);
    for (int i = 1; i <= n; ++i) f[i] = i;
    for (int i = 1; i <= n; ++i)
    {
        if (!query(a[i].t)) m -= a[i].w;
        else f[f[a[i].t]] = f[a[i].t] - 1;
    }
    printf("%d", m);
    return 0;
}
```

### 流水作业调度问题

有 $n$ 个零件，第 $i$ 个零件要先在机器 A 上加工 $a_i$ 的时间，再在机器 B 上加工 $b_i$ 的时间。确定 $n$ 个零件的加工顺序，使得花费的总时间最短。

做法是，让最优解的处理队列的前半部分是 $a_i\leq b_i$ 的任务按 $a_i$ 升序排列，后半部分是 $a_i>b_i$ 的任务按 $b_i$ 降序排列。

接下来证明该贪心策略。

首先明确，从机器 A 开始加工开始，就可以连续不断地工作，直到处理完所有零件。如果机器 B 要加工一个零件，要满足机器 A 已经加工完该零件、机器 B 已经加工完上一个零件这两个要求。也就是，机器 A 的加工时间是一定的，影响最终答案的是机器 B 的加工结束时间。这样下来，最优解的比较就只剩下了一维描述，可以适用贪心法。

对于当前要加工第 $i$ 个零件，自机器 A 加工完第 $i-1$ 个零件过了 $t$ 个单位时间机器 B 加工完第 $i-1$ 个零件，可以得出递推式

$$
T_i=T_{i-1}-t+\\max\\{a_i,t\\}+b_i
$$

我们采用排序思想确定加工顺序，假设当前有零件 $i,j$ 要加工，已经确定加工顺序并已加工的零件总用时为 $T_0$，对应的机器 A、B 结束工作的时间差为 $t_0$，那么

对于先加工 $i$，再加工 $j$ 的方案

$$
\\begin{align}
T&=\\max\\{T_0-t_0+a_i+a_j,\\max\\{T_0-t_0+a_i,T_0\\}+b_i\\}+b_j\\\\
 &=T_0+\\max\\{-t_0+a_i+a_j,\\max\\{-t_0+a_i,0\\}+b_i\\}+b_j\\\\
 &=T_0-t_0+\\max\\{a_i+a_j,\\max\\{a_i,t_0\\}+b_i\\}+b_j\\\\
 &=T_0-t_0+b_i+b_j+\\max\\{a_i+a_j-b_i,a_i,t_0\\}
\\end{align}
$$

对于先加工 $j$，再加工 $i$ 的方案

$$
T'=T_0-t_0+b_i+b_j+\\max\\{a_i+a_j-b_j,a_j,t_0\\}
$$

$T\leq T'$ 的充分必要条件是

$$
\\begin{align}
\\max\\{a_i+a_j-b_i,a_i,t_0\\}&\\leq\\max\\{a_i+a_j-b_j,a_j,t_0\\}\\\\
                           &\\Uparrow\\\\
    \\max\\{a_i+a_j-b_i,a_i\\}&\\leq\\max\\{a_i+a_j-b_j,a_j\\}\\\\
                           &\\Updownarrow\\\\
          \\max\\{-b_i,-a_j\\}&\\leq\\max\\{-b_j,-a_i\\}\\\\
                           &\\Updownarrow\\\\
            \\min\\{a_i,b_j\\}&\\leq\\min\\{a_j,b_i\\}
\\end{align}
$$

即零件 $i$ 安排在零件 $j$ 前加工的充分条件是 $\\min\\{a_i,b_j\\}\\leq\\min\\{a_j,b_i\\}$。

$1^\circ$ 当 $a_i\leq b_i,a_j\leq b_j,a_i\leq a_j$ 时，有 $\\min\\{a_i,b_j\\}=a_i\\leq\\min\\{a_j,b_i\\}$，零件 $i$ 应该排在零件 $j$ 之前加工。

$2^\circ$ 当 $a_i\geq b_i,a_j\geq b_j,b_i\geq b_j$ 时，有 $\\min\\{a_i,b_j\\}=b_j\\leq\\{a_j,b_i\\}$，零件 $i$ 应该排在零件 $j$ 之前加工。

$3^\circ$ 当 $a_i\leq b_i,a_j\geq b_j$ 时，有 $\\min\\{a_i,b_i,a_j,b_j\\}=\\min\\{a_i,b_j\\},\\max\\{a_i,b_i,a_j,b_j\\}=\\min\\{a_j,b_i\\}$，故 $\\min\\{a_i,b_j\\}\\leq\\min\\{a_j,b_i\\}$，零件 $i$ 应该排在零件 $j$ 之前加工。

否则零件 $i$ 应该排在零件 $j$ 之后加工。

这里还需注意，我们只是考虑了零件 $i,j$ 紧接着加工的情况，因此还不够完善。

结合结论 $3$，用反证法可以证明，$a\leq b$ 的所有零件应该排在 $a>b$ 的所有零件之前。

再结合结论 $1,2$，在 $a\leq b$ 的所有零件内部，应按照 $a$ 升序排列；在 $a>b$ 的所有零件内部，应按照 $b$ 降序排列。

贪心策略得证。

#### T9 加工生产调度

评测链接：<https://loj.ac/p/10003>

某工厂收到了 $n$ 个产品的订单，这 $n$ 个产品分别在 A、B 两个车间加工，并且必须先在 A 车间加工后才可以到 B 车间加工。

某个产品 $i$ 在 A，B 两车间加工的时间分别为 $A_i,B_i$。怎样安排这 $n$ 个产品的加工顺序，才能使总的加工时间最短。

这里所说的加工时间是指：从开始加工第一个产品到最后所有的产品都已在 A，B 两车间加工完毕的时间。

```cpp
#include <cstdio>
#include <algorithm>

template <class T>
T max(T x, T y)
{
    return x > y ? x : y;
}

int n, a[10005], b[10005], na = 0, nb = 0;

struct prod
{
    int ta, tb, id;
} A[10005], B[10005];

bool cmp1(prod x, prod y)
{
    return x.ta < y.ta;
}

bool cmp2(prod x, prod y)
{
    return x.tb > y.tb;
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d", a + i);
    for (int i = 1; i <= n; ++i) scanf("%d", b + i);
    for (int i = 1; i <= n; ++i)
    {
        if (a[i] <= b[i])
        {
            ++na;
            A[na].ta = a[i];
            A[na].tb = b[i];
            A[na].id = i;
        }
        else
        {
            ++nb;
            B[nb].ta = a[i];
            B[nb].tb = b[i];
            B[nb].id = i;
        }
    }

    std::sort(A + 1, A + na + 1, cmp1);
    std::sort(B + 1, B + nb + 1, cmp2);

    int TA = 0, TB = 0;
    for (int i = 1; i <= na; ++i)
    {
        TA += A[i].ta;
        TB = max(TA, TB) + A[i].tb;
    }
    for (int i = 1; i <= nb; ++i)
    {
        TA += B[i].ta;
        TB = max(TA, TB) + B[i].tb;
    }
    printf("%d\n", TB);
    for (int i = 1; i <= na; ++i) printf("%d ", A[i].id);
    for (int i = 1; i <= nb; ++i) printf("%d ", B[i].id);

    return 0;
}
```

## 贪心反悔

我们之前提到过，即使在地上捡了 $10$ 元的大洋，之后再遇到 $100$ 大洋的时候大可以放弃 $10$ 元的，这是反悔操作的一个简单示例。

反悔表示，我们在贪心的过程中，得出的结果不一定是全局最优解的组成部分，我们之后还有可能对其做出调整。一般来说，是会在做出贪心选择的同时，对处理对象进行一些修改，使其接下来某一步正常贪心操作的时候，达到反悔的效果。

### T10 数据备份

评测链接：<https://www.luogu.com.cn/problem/P3620>

在直线坐标系上给出 $N$ 个点，要求选择 $2K$ 个不同的点作为端点生成 $K$ 条线段，使得线段总长度最小。$1\leq N\leq 10^5,1\leq K\leq N/2$。

<br>

首先需要明确，对于最优解，选择的两条线段不会有重合部分，反证法可证。那么，为了最小化长度总和，选择的线段端点一定是坐标系上相邻的两个点。于是问题就转化成了，在 $N-1$ 条可选线段中选 $K$ 条不相邻的，使长度总和最小。

一般来说，贪心地想，都会选择合法可选的、最近的两个端点来生成线段。但是这样有一个非常明显的问题，就是加入我们选取了一条优秀的线段，就可能会导致与其相邻的两条较为优秀的线段不可选，就可能错失最优解。

我们想到，在有限次内，同时选这两条较为优秀的线段可能还没有必要，但是再增加几次选择的机会，就可能需要弃选最优秀的线段而同时选择两条较为优秀的线段。试想，是否可以反悔，到时候如果有机会且有必要这样做，就放弃已经选过的最优秀的选段，转而同时选择两条较为优秀的线段。

聪明的孩子，看看下面的思路。

每次贪心地选取最优秀的线段过后，假设它左边线段的长度为 $x_l$，它的长度为 $x$，它右边线段的长度为 $x_r$，那么删除这三条可选线段，并在原位置加入一条新的可选线段，长度为 $x_l+x_r-x$。如果选了它，则代表弃选这条线段，转而选择与其相邻的两条。

此时此刻此景，问君心生何情？

```cpp
#include <cstdio>
#include <vector>
#include <queue>

using namespace std;

int n, k, x, y, z, Ans = 0;
int d[100005], nxt[100005], lst[100005];
bool f[100005];
struct cmp
{
    bool operator ()(int x, int y)
    {
        return d[x] > d[y];
    }
};
priority_queue<int, vector<int>, cmp> q;

int main()
{
    scanf("%d%d", &n, &k);
    scanf("%d", &y);
    for (int i = 1; i < n; ++i)
    {
        scanf("%d", &x);
        z = x - y;
        y = x;
        d[i] = z;
        lst[i] = i - 1;
        nxt[i] = i + 1;
        q.push(i);
        f[i] = true;
    }
    d[0] = 0x3f3f3f3f;
    d[n] = 0x3f3f3f3f;
    
    for (int i = 1; i <= k; ++i)
    {
        while (not f[q.top()]) q.pop();
        x = q.top();
        q.pop();
        f[x] = false;
        
        Ans += d[x];
        
        d[x] = d[lst[x]] + d[nxt[x]] - d[x];
        f[lst[x]] = false;
        f[nxt[x]] = false;
        lst[x] = lst[lst[x]];
        nxt[x] = nxt[nxt[x]];
        nxt[lst[x]] = x;
        lst[nxt[x]] = x;
        q.push(x);
        f[x] = true;
    }
    printf("%d", Ans);
    return 0;
}
```

## 问君

君言道，贪心何尝不是目如井蛙，错顾良机？

试问君，可知贪心亦可步步为棋，留匿归途？

今天让你活在当下，精心打理好每一天。明天是虚无缥缈，但你必须可以永远相信明天的你。

直面的贪心，仅仅是因为人类最原始的欲望，也仅仅是因为当下即存在可以珍惜的美好。
