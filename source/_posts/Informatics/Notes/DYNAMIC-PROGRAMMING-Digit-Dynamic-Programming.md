---
title: 动态规划 - 数位动态规划
tags:
  - '[I] 动态规划'
categories:
  - Informatics
  - Notes
date: 2022-07-12 21:30:24
---


古老的十进位制，新生的数位 DP

<!--more-->

## 进位制

进位制诞生于数学初生之时，为了用有限的数字组合表达出任何数，不重不漏，就是进位制的初心。

常用的有十进制、二进制、八进制、十六进制、六十进制。人类选择了十进制，根据解剖学观点，这与人类拥有十根手指有关，这也证实了人类最原始的计数方法。当然也有如古代两河流域的苏美尔人，选择了六十进位制。

进位制的选择影响了数的表现形式，也会导致一些数字的特殊性。

比如 3 和 9 的倍数判断可以用各位数字相加，7、11、13 的倍数判断可以用奇段和减去偶段和，这些都是与十进位制相关的。

因此，如果有一道题与进位制的选择有关，换言之，与数位的表现形式有关，那么就可以选择拆开各数位，作为一个数列来进行处理。

其中，一个具有代表性的算法，数位 DP。

## 数位 DP

数位 DP 的基本原理是把一个十进制数拆成各数位进行处理。

因此，数位 DP 的题目一般会与进位制的选择有关。并且，各个数位之间相对独立，又可以按照数位来进行阶段划分。

再者，对于我们最开始要处理的对象也就是数，一般范围很大，暴力枚举会超时，用数位 DP 后时间复杂度会包含一个 $\lg$ 或者 $\log_x$（$x$ 由进位制的选择决定）。

数位 DP 还有以下特征：

  1. 我们运用数位 DP 的时候，往往会有预处理的过程，然后是一个统计答案的过程。

  2. 一般对于区间 $[a,b]$ 的问题，会将它转换为 $[1,b]$ 和 $[1,a-1]$ 两个问题之差，只考虑上界，方便统计。

## T 数字计数

题目来源：ZJOI2010
评测链接：<https://www.luogu.com.cn/problem/P2602>

给定两个正整数 $a$ 和 $b$，求在 $[a,b]$ 中的所有整数中，每个数码(digit)各出现了多少次。$1 \le a,b \le 10^{12}$。

<br>

这道题提示的就过于明显了，就连标题都在拼命提醒你这道题与数位有关，再定睛一看，数位 DP 原形毕露。

根据数位 DP 的一般套路，将问题化为关于 $[1,b]$ 和 $[1,a-1]$ 两个问题，那么就考虑关于 $[1,l]$ 的问题应该怎么处理。

对于这种有上界的数位 DP，我们会发现从高位到低位取数字，如果取得的数字小于上界中这一位上的数字，那么接下来低位的数字无论怎么取都不会超过上界，因此这就是一个完美的子问题，不需要过多判断，预处理出 DP 数组即可。

这样，我们就可以从高位到低位枚举，在每一位，选择小于上界的数字直接进行统计，选择等于上界的数字继续往低位枚举。

具体来说，比如上界是 $12345$，目前已经取得的前 $2$ 位是 $12$，正在考虑第 $3$ 位的取值。如果第三位取 $0,1,2$，那么这三者接下来的数字选择都是一致的，不用搜索式地扫描；如果第 $3$ 位取 $3$，那么就看作前三位取定了 $123$，继续进行第 $4$ 位的统计。

接着回归到这道题上来，先不考虑前导 $0$。

本题要求统计数字出现的个数，首先考虑预处理的 DP 数组，可以发现对于所有 $k$ 位数字，$0-9$ 出现的次数是均等的，因此可以用 $f_i$ 表示 $k$ 位数字组成的所有数中，每个数字出现的次数。

考虑递推式，对于已经取定 $k$ 位数字的所有数中，每个数字总共出现 $f_k$ 次，再取下一位，由于下一位有 $10$ 中选择，因此在 $k+1$ 位数字的所有数中，每个数字在前 $k$ 位总计出现 $10f_k$ 次。再来，前 $k$ 位数字一共有 $10^k$ 种组合，因此在 $k+1$ 位数字的所有数中，每个数字在第 $k+1$ 位总计出现 $10^k$ 次。

于是就有 $f_{k+1}=10f_k+10^k$，整理得

$$
f_i=10f_{i-1}+10^{i-1}
$$

也可以由「对于所有 $k$ 位数字，$0-9$ 出现的次数是均等的」这一结论，得到 $f_i=\frac{i \times 10^i}{10}=10^{i-1}i$，这与递推式是一致的。

预处理出 DP 数组，我们考虑如何统计答案。

先来一个形象一点的定义，我们在按照上界从高位向低位枚举的过程中，大手一挥解决了上界以下的所有情况，然后又小心翼翼地处理高位与上界相等的情况。后者我们可以称为「贴着上界」。

从高位到低位枚举的过程中，上界的第 $i$ 位为 $x$。

不贴着上界的情况：第 $i$ 位有 $x$ 种取法，后 $len-i$ 位还有 $10^{len-i}$ 种组合，即第 $i$ 位为 $[0,x-1]$ 的每个数字贡献了 $10^{len-i}$；接下来 $len-i$ 位每个数字出现次数为 $f_{len-i}$，第 $i$ 位有 $x$ 种取值，因此后 $len-i$ 位为 $[0,9]$ 的每个数字贡献了 $f_{len-i}x$。至于还有前 $i-1$ 位，在贴着上界的情况讨论。

贴着上界的情况：第 $i$ 位取值必定是 $x$，还要考虑后 $len-i$ 位的贴着上界和不贴着上界的第 $i$ 位部分贡献，而在前 $i$ 位确定与上界相等时，后 $len-i$ 位还会出现 $l \mod 10^{len-i}$ 次，因此第 $i$ 位为 $x$ 贡献了 $l \mod 10^{len-i}$。

然后考虑前导 0，当我们的上界有 $len$ 位时，要统计有 $k$ 个前导 0 的情况，那么有 $k$ 个前导 0 的数有 $10^{len-k}$ 个，于是就有 $k \times 10^{len-k}$ 个前导 0 被错误地统计，从 $0$ 的答案中删去即可。

```cpp
#include <cstdio>

long long a, b, c[15];
long long f[15], p[15];
long long ans1[10], ans2[10];

void preset()
{
    p[0] = 1;
    for (int i = 1; i <= 13; ++i)
    {
        f[i] = f[i - 1] * 10 + p[i - 1];
        p[i] = p[i - 1] * 10;
    }
}

void work(long long l, long long *ans)    // 计算区间 [1,l] 的答案
{
    long long tmp = l;
    int len = 0;
    while (tmp) tmp /= 10, ++len;    // 统计 l 的位数

    for (int i = 1; i <= len; ++i)
    {
        int x = l % p[len - i + 1] / p[len - i];
        for (int j = 0; j <= 9; ++j) ans[j] += f[len - i] * x;    // 不贴着上界，后 len - i 位的贡献
        for (int j = 0; j < x; ++j) ans[j] += p[len - i];    // 不贴着上界，第 i 位的贡献
        ans[x] += l % p[len - i] + 1;    // 贴着上界
        ans[0] -= p[len - i];    // 去除错误计算的前导 0
    }
}

int main()
{
    scanf("%lld%lld", &a, &b);
    
    preset();

    work(a - 1, ans1);
    work(b, ans2);

    for (int i = 0; i <= 9; ++i) printf("%lld ", ans2[i] - ans1[i]);

    return 0;
}
```

## T windy 数

题目来源：SCOI2009
评测链接：<https://www.luogu.com.cn/problem/P2657>)

不含前导零且相邻两个数字之差至少为 $2$ 的正整数被称为 windy 数。windy 想知道，在 $a$ 和 $b$ 之间，包括 $a$ 和 $b$ ，总共有多少个 windy 数？$1 \leq a \leq b \leq 2 \times 10^9$。

<br>

有对相邻两个数字进行限制，那么很明显要在数位上进行操作。

由于对数位上的数字有要求，因此预处理 DP 数组加一位，用 $f_{i,j}$ 表示以 $j$ 打头的 $i$ 位数字组成的所有数中，有多少个 windy 数。

很明显有

$$f_{i,j} = \sum_{k \in [0,9] \land |j-k|} f_{i-1,k}$$

在从高位到低位扫描的过程中，如果出现上界数字的这一位与上一位相差超过了 $2$，那么接下来再贴着上界就是不合法的，此时就打一个 $flag$，标记是否继续统计。

为了避免第一位不合法，因此将第一位的上一位设为 $-2$。

然后依然是前导 $0$ 的问题，如果有多个前导 $0$，原本的程序就不能将其判断为 windy 数，此时就只需额外手动加上含前导 $0$ 的 windy 数。

但还需注意，因为只含 $1$ 个前导 $0$ 是能被判断为 windy 数的，因此这一部分被重复统计，最后计算的时候减去即可。

```cpp
#include <cstdio>
#include <cmath>

int a, b;
long long p[12];
int f[12][10];

void preset()
{
    p[0] = 1;
    for (int i = 1; i <= 11; ++i) p[i] = p[i - 1] * 10;

    for (int i = 0; i <= 9; ++i) f[1][i] = 1;
    for (int i = 2; i <= 11; ++i)
    {
        for (int j = 0; j <= 9; ++j)
        {
            for (int k = 0; k <= j - 2; ++k) f[i][j] += f[i - 1][k];
            for (int k = j + 2; k <= 9; ++k) f[i][j] += f[i - 1][k];
        }
    }
}

int solve(int l)
{
    int tmp = l, len = 0;
    while (tmp) tmp /= 10, ++len;

    int ans = 0, ls = -2;
    bool flag = false;
    for (int i = 1; i <= len; ++i)
    {
        if (!flag)
        {
            int x = l % p[len - i + 1] / p[len - i];
            if (abs(x - ls) < 2)
            {
                for (int j = 0; j <= ls - 2; ++j) ans += f[len - i + 1][j];
                flag = true;
            }
            else
            {
                for (int j = 0; j <= ls - 2 && j < x; ++j) ans += f[len - i + 1][j];
                for (int j = ls + 2; j <= 9 && j < x; ++j) ans += f[len - i + 1][j];
                ls = x;
            }
        }
        for (int j = 1; j <= 9; ++j) ans += f[len - i][j];
    }
    return ans - f[len][0];
}

int main()
{
    scanf("%d%d", &a, &b);
    preset();
    printf("%d\n", solve(b + 1) - solve(a));
    return 0;
}
```

## 统计答案

这里用图来解释一下数位 DP 统计答案的过程。

我们能够用树形结构表示出指定位数的指定进制数，下图以二进制为例。

{% asset_img count.png '"" "数位 DP 统计答案"' %}

红色部分就是我们的上界。

显而易见，红色部分为一条路径，而紫色和绿色部分则均为一棵满（二叉）树。

按照我们上面的思路，这几棵满树就是我们要 DP 预处理的地方。因为我们构造的数位树里，每个结点的子结点都是一样的，因此子树的形态只与树的深度、根的权值有关。所以我们才能够用 DP 的方式递推求出预处理数组。

然后，我们统计答案。贴着上界，也就是顺着红色路径走，我们以路径左侧所有结点中与红色路径距离为 $1$ 的点作为根节点，找出一些满树，也就是紫色和绿色部分，然后将这些满树的 DP 预处理结构进行整合（不一定是简单相加）。最后，留心一下上界是否被疏忽，即可。

## 总结

数位 DP 似乎已经脱离了 DP 的「阶段性决策问题」，但它还是可以用动态规划的思想来解决，这也更加证明了动态规划实质是一种思想。

在进位制的助力下，相关问题可以通过拆分数位进行解决，这就是数位 DP 的核心所在。

我们常常会看过太多太多的人生百态，始终追求着这场游戏的上界。为了上界，却常常会在上界之下踌躇，机械般地重复着大体相同的工作，而上界却依然可望而不可即。

其实看看，在追求梦想的征途上，花儿是一样的鲜艳，天气是一样的阴晴，春风是一样的和煦，草木是一样的芬芳。学会学习，将经验化作智慧，不再去劳碌地周而复始。

这样，才会拥有带 $\lg$ 的效率，才会更快地触及上界，才会有机会破开上界的桎梏。
