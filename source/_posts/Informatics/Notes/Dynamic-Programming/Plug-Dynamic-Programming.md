---
title: 动态规划 - 插头动态规划
tags:
  - '[I] 动态规划'
categories:
  - Informatics
  - Notes
date: 2022-11-01 22:28:28
---


淮河边上相守望

<!--more-->

## 轮廓线 DP

在介绍插头 DP 之前，我们先看一个经典问题——骨牌覆盖。

### T Mondriaan's Dream

题目来源：HDU 1400
评测链接：<https://vjudge.net/problem/HDU-1400>

在 $N\times M(1\leq N,M\leq 11)$ 的棋盘上铺满 $1\times2$ 或 $2\times1$ 的骨牌，询问方案数。

一般状压 DP 的做法是，状态压缩每一行的状态，逐行转移。

轮廓线 DP 的做法是，状态压缩轮廓线上的状态，逐格转移。

轮廓线的概念，就是尚未 DP 的格子与已经 DP 过的格子的分界线，如下。

{% asset_img contourlines.png '"" "轮廓线"' %}

显然，轮廓线并不是格子，因此我们假定状态压缩恰好在轮廓线上的格子的状态，在上图中也就是 $(2,1),(2,2),(1,3),(1,4)$。

于是，在 DP 过程中，我们定义 $f_{i,j,s}$ 表示转移到 $(i,j)$，状态为 $s$ 的方案数。我们假定当前处理的格子 $(i,j)$ 位于轮廓线上方。那么当 $(i,j)$ 的状态为 $1$，也就是 $(i,j)$ 放置了一个竖放骨牌的上半部分时，应当从 $f_{i,j-1,s\oplus(1<<j-1)}$ 转移；否则，应当从 $f_{i,j-1,s\oplus(1<<j-1)}$（表示竖放骨牌的下半部分）和 $f_{i,j-2,s}$（表示横放骨牌）转移。

同时，我们在每一行开始之前，应当从 $(i-1,m)$ 的所有 DP 状态复制到 $(i,0)$，这样轮廓线实质不会变化，便于 DP 转移。

用轮廓线 DP 做这道题，时间复杂度是 $O(nm2^m)$，优于状压 DP $O(n2^{2m})$。

{% contentbox type:success title:参考代码 %}
```cpp
#include <cstdio>

int N, M, T;
long long f[15][15][1 << 11];

int main()
{
    while (scanf("%d%d", &N, &M) != EOF)
    {
        if (N == 0 && M == 0) return 0;
        T = 1 << M;
        f[0][M][0] = 1;
        for (int i = 1; i <= N; ++i)
        {
            for (int k = 0; k < T; ++k) f[i][0][k] = f[i - 1][M][k];
            for (int j = 1; j <= M; ++j)
            {
                for (int k = 0; k < T; ++k)
                {
                    f[i][j][k] = f[i][j - 1][k ^ (1 << j - 1)];
                    if (j > 1 && !(k & (3 << j - 2)))
                        f[i][j][k] += f[i][j - 2][k];
                }
            }
        }
        printf("%lld\n", f[N][M][0]);
    }
    return 0;
}
```
{% endcontentbox %}

## 插头 DP

插头 DP 的概念应该最早见于陈丹琦的论文《基于连通性状态压缩的动态规划问题》，显而易见插头 DP 属于一种特殊的状压 DP，并且处理的是有关连通性的问题。因此，我们以下讨论的是相邻格子的连通性，比如在棋盘上用一条路径覆盖，路径上相邻的结点就是连通的格子。

我们称一个格子具有某个方向的插头，表示格子与该方向上相邻的格子相连。

我们称轮廓线上某个位置存在插头，表示该位置两边的格子相连。在下图中，轮廓线与黑色路径相交的位置就存在插头。

{% asset_img plugsoncontourlines.png '"" "轮廓线上的插头"' %}

因为轮廓线的长度为 $m+1$，所以状态压缩也是 $m+1$ 位的，其中包含 $m$ 个竖直插头和 $1$ 个水平插头。

## T Eat the Trees

题目来源：HDU 1693
评测链接：<https://vjudge.net/problem/HDU-1693>

用若干条回路覆盖 $N\times M$ 的棋盘，有些位置存在障碍物，求方案数。

本题等价转化为，每个不存在障碍物的格子有且仅有两个插头存在的方案数。

我们用 $0$ 和 $1$ 表示轮廓线上插头的存在性。那么，当我们的轮廓线从下图左转移到下图右的时候，可能有以下几种情况。

{% asset_img plugdp.png '"" "插头 DP 转移"' %}

  1. 从 $1,2$ 均不存在插头转移到 $3,4$ 均存在插头。
  2. 从 $1,2$ 均存在插头转移到 $3,4$ 均不存在插头。
  3. 从 $1,2$ 其一存在插头转移到 $3,4$ 其一存在插头。

对于填表法的 DP，如果 $3,4$ 状态一致，则从 $s\oplus(3<<j-1)$ 转移；否则，从 $s\oplus(3<<j-1)$ 和 $s$ 转移。

在 Mondriaan's Dream 一题中，我们将 $(i-1,m)$ 的状态复制到 $(i,0)$，这里我们同样应该进行类似操作。一行合法的末尾值应为最后一个（水平）插头不存在，一行合法的起始值应为第一个（水平）插头不存在，在满足这个条件下复制。复制的合理性直观证明。

{% asset_img copy.png '"" "状态复制"' %}

边界条件很简单，就是 $f_{0,m,0}=1$，因为此时的轮廓线上不能有任何插头。

答案在 $f_{n,m,0}$，同样也是此时的轮廓线上不能有任何插头。

{% contentbox type:success title:参考代码 %}
  ```cpp
  #include <cstdio>
  
  int T, N, M;
  int a[15][15];
  
  long long f[15][15][1 << 12];
  
  int main()
  {
      scanf("%d", &T);
      for (int test = 1; test <= T; ++test)
      {
          scanf("%d%d", &N, &M);
          for (int i = 1; i <= N; ++i) for (int j = 1; j <= M; ++j) scanf("%d", &a[i][j]);
  
          f[0][M][0] = 1;
          for (int i = 1; i <= N; ++i)
          {
              for (int k = 0; k < (1 << M); ++k) f[i][0][k << 1] = f[i - 1][M][k];
              for (int j = 1; j <= M; ++j)
              {
                  for (int k = 0; k < (1 << M + 1); ++k)
                  {
                      if (!a[i][j])
                      {
                          if (!(k & (3 << j - 1))) f[i][j][k] = f[i][j - 1][k];
                          else f[i][j][k] = 0;
                      }
                      else
                      {
                          if (!!(k & (1 << j - 1)) == !!(k & (1 << j))) f[i][j][k] = f[i][j - 1][k ^ (3 << j - 1)];
                          else f[i][j][k] = f[i][j - 1][k ^ (3 << j - 1)] + f[i][j - 1][k];
                      }
                  }
              }
          }
  
          printf("Case %d: There are %lld ways to eat the trees.\n", test, f[N][M][0]);
      }
      return 0;
  }
  ```
{% endcontentbox %}

显然，对于骨牌覆盖问题，我们也可以稍作修改使其满足插头 DP 的特征。

## T 【模板】插头dp

评测链接：<https://www.luogu.com.cn/problem/P5056>

给出 $n\times m$ 的方格，有些格子不能铺线，其它格子必须铺，形成一个闭合回路。问有多少种铺法？

此题相较于上一题，还需要保证只包含一个闭合回路。我们思考，在逐格 DP 的过程中，一个回路完整地形成是什么时候。当轮廓线推进的时候，如果两个插头在轮廓线上方通过某条路径相连，并且在当前格子里相碰，那么就完整地形成了一个闭合回路。

而对于轮廓线上的插头，很明显是两两配对的，配对的两个插头在轮廓线上方通过一条路径相连，无论它多么复杂，并且易证这条路径会且仅会在这两个插头处接触轮廓线。

{% asset_img template.png 模板 %}

比如在上图中，$A$ 与 $D$ 相连，$B$ 与 $C$ 相连。并且很容易看出来，在轮廓线上从左往右分布的四个插头 $A,B,C,D$，不会出现 $(A,C),(B,D)$ 相连的情况。

这个时候我们状态压缩不仅需要记录插头的连通性，还要记录插头的两两相连，一般有两种编码方式。

**最小表示法**，对每对相连的插头编号赋值，以靠左插头的左右顺序为序，采用 $p$ 进制存储，$p$ 至少要大于 $m/2$。

**括号表示法**，根据插头的两两相连，生成一个合法括号序列，采用 $3$ 进制存储。

无论选取哪一种，都可以再通过将合法状态哈希到一个序列中去，来缩小可选状态范围。我们这里选取更加简单的括号表示法。

有了状态，我们考虑转移。转移可能有一下几种情况：

  1. 对左插头和上插头存在其一的情况，延伸路径，更新路径在轮廓线上的交点位置。
  2. 对左插头和上插头均存在的情况，说明这两个插头将在轮廓线以下相连。如果这两个插头本就已经在轮廓线以上相连，则这次合并会完整生成一个闭合回路。是非法的，应当转移为 $0$。否则，就应该合并这两个插头所属的路径。如果是 $)($ 直接合并，如果是 $(($ 则需向右找到匹配的 $)$ 改成 $($，如果是 $))$ 亦同理。
  3. 对左插头和上插头均不存在的情况，只有 $()$ 能够新建一对相连的插头，否则状态非法，转移为 $0$。

当然，我们只需要一次合并 $()$ 的情况，这会出现在整张棋盘最后一个非障碍物的格子上，此时我们特殊转移一下即可。

{% contentbox type:success title:参考代码 %}
```cpp
#include <cstdio>

const int pow[] = {1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441, 1594323};

int n, m;
char a[15][15];
long long f[15][1600000];

int p[1600000], r[1600000], tot = 0;

int ex = 0, ey = 0;

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) for (int j = 1; j <= m; ++j)
    {
        scanf(" %c", &a[i][j]);
        if (a[i][j] == '.') ex = i, ey = j;
    }

    for (int i = 0; i < pow[m + 1]; ++i)
    {
        int cnt = 0;
        for (int j = 0; j <= m; ++j)
        {
            if (i / pow[j] % 3 == 1) ++cnt;
            else if (i / pow[j] % 3 == 2)
            {
                --cnt;
                if (cnt < 0) break;
            }
        }
        if (cnt == 0)
        {
            p[i] = tot;
            r[tot] = i;
            ++tot;
        }
        else p[i] = pow[m + 1];
    }

    f[m][0] = 1;
    for (int i = 1; i <= ex; ++i)
    {
        for (int k = 0; r[k] < pow[m]; ++k) f[0][p[r[k] * 3]] = f[m][k];
        for (int j = 1; j <= m; ++j)
        {
            for (int k = 0; k < tot; ++k)
            {
            #define s r[k]
                int down = s / pow[j - 1] % 3, right = s / pow[j] % 3;
                if (a[i][j] == '*')
                {
                    if (down == 0 && right == 0) f[j][k] = f[j - 1][k];
                    else f[j][k] = 0;
                }
                else
                {
                    if (down == 0 && right == 0)
                    {
                        f[j][k] = f[j - 1][p[s + 2 * pow[j - 1] + 1 * pow[j]]];
                        int cnt = 0;
                        for (int d = j + 1; d <= m && cnt >= 0; ++d)
                        {
                            if (s / pow[d] % 3 == 1)
                            {
                                if (!cnt) f[j][k] += f[j - 1][p[s + 1 * pow[j - 1] + 1 * pow[j] + pow[d]]];
                                ++cnt;
                            }
                            if (s / pow[d] % 3 == 2) --cnt;
                        }
                        cnt = 0;
                        for (int d = j - 2; d >= 0 && cnt >= 0; --d)
                        {
                            if (s / pow[d] % 3 == 2)
                            {
                                if (!cnt) f[j][k] += f[j - 1][p[s + 2 * pow[j - 1] + 2 * pow[j] - pow[d]]];
                                ++cnt;
                            }
                            if (s / pow[d] % 3 == 1) --cnt;
                        }
                    }
                    else if (down && right)
                    {
                        if (down == 1 && right == 2) f[j][k] = f[j - 1][p[s - 1 * pow[j - 1] - 2 * pow[j]]];
                        else f[j][k] = 0;
                    }
                    else f[j][k] = f[j - 1][k] + f[j - 1][p[s + (right - down) * pow[j - 1] + (down - right) * pow[j]]];
                }
            #undef s
            }
        }
    }

    printf("%lld\n", f[ey - 1][p[1 * pow[ey - 1] + 2 * pow[ey]]]);

    return 0;
}
```
{% endcontentbox %}

## 总结

插头 DP，就是状态压缩轮廓线上插头的信息，进行状态转移的动态规划。而我们在轮廓线上存留的插头信息，都是轮廓线这端对轮廓线那端产生的影响。在逐格 DP 的过程中，我们处理一个插头并记录下一个插头，生生不息，往复不止。

插头，是跨越轮廓线的交织，是轮廓线这头向那头的共舞。

淮河分南北，橘在那头，枳在这头，跨越淮河仍然相互守望。
