---
title: 动态规划 - 线性动态规划
tags:
  - '动态规划'
categories:
  - Informatics
  - Notes
date: 2022-04-04 13:11:03
---


梦开始的地方——初识 DP 之路

<!--more-->

## 从递归递推到动态规划

### T 菲波那契数列

评测链接：<http://ybt.ssoier.cn:8088/problem_show.php?pid=1201>

菲波那契数列是指这样的数列: 数列的第一个和第二个数都为 $1$ ，接下来每个数都等于前面 $2$ 个数之和。

给出一个正整数 $a(1\leq a\leq 20)$ ，要求菲波那契数列中第 $a$ 个数是多少。

<br>

定义函数 $f(x)$ 为斐波那契数列中的第 $x$ 项，根据题意很明显有

$$
\\begin{eqnarray}    f(x) =    \\begin{cases}        1             & x=1\\lor x=2 \\\\        f(x-2)+f(x-1) & x>2    \\end{cases}\\nonumber\\end{eqnarray}
$$
于是可以写出一段十分朴素的代码，即递归解法。

{% contentbox type:success title:参考代码 %}
```cpp
#include <cstdio>

int f(int x)
{
    if (x <= 2) return 1;
    else return f(x - 2) + f(x - 1);
}

int main()
{
    int n, a;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d", &a);
        printf("%d\n", f(a));
    }
    return 0;
}
```
{% endcontentbox %}

在下面这道题目中，我们可以看出上面这段代码有着不可避免的缺陷。

### T 菲波那契数列 (2)

评测链接：<http://ybt.ssoier.cn:8088/problem_show.php?pid=1188>

菲波那契数列是指这样的数列：数列的第一个和第二个数都为 $1$ ，接下来每个数都等于前面 $2$ 个数之和。

给出一个正整数 $a(1 <= a <= 1000000)$ ，要求菲波那契数列中第 $a$ 个数对 $1000$ 取模的结果是多少。

<br>

这道题与上一题差别似乎仅仅在数据范围，但仅仅用上一题的算法是会超时的，而我们只能仅仅得到 0 分的优秀成绩。

至于为什么会超时，其实不难发现，在我们每次计算 $f(x)$ 的时候，我们都会递归调用 $f(x-2)$ 和 $f(x-1)$ ，直到调用到 $f(1)$ 或 $f(2)$ 为止。而我们每次计算出 $f(x)$ 返回过后直接舍弃，导致每一次调用的时候都要重新计算。比如说计算 $f(5)$ 时要计算 $f(3)$ 和 $f(4)$ ，而计算 $f(4)$ 时要计算 $f(2)$ 和 $f(3)$ ，这样 $f(3)$ 就会重复计算。数字大了，重复计算的次数会更多，自然会浪费时间。

我们处理这样的问题，有两种思路，一是记忆化搜索，即计算完 $f(x)$ 后将其存下来；二是变递归为递推，通过已知量主动推出待求量，而不是递归式的层层询问。

这里是记忆化搜索的代码， 跟上一题相差无几。

{% contentbox type:success title:参考代码 %}
```cpp
#include <cstdio>

int F[10000005]={0, 1, 1};

int f(int x)
{
    if (!F[x]) F[x] = (f(x - 2) + f(x - 1)) % 1000;
    return F[x];
}

int main()
{
    int n, a;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d", &a);
        printf("%d\n", f(a));
    }
    return 0;
}
```
{% endcontentbox %}

至于递推写法，也需要开一个数组存储。每次询问 $f(x)$ 时，如果已经推算过，直接输出，如果没有，则从上次递推结束的地方开始继续递推，推到 $x$ 为止。

{% contentbox type:success title:参考代码 %}
```cpp
#include <cstdio>

int F[1000005] = {0, 1, 1}, t = 2;

int f(int x)
{
    if (x <= t) return F[x];
    for (; t <= x; ++t)
        F[t] = (F[t - 2] + F[t - 1]) % 1000;
    return F[x];
}

int main()
{
    int n, a;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d", &a);
        printf("%d\n", f(a));
    }
    return 0;
}
```
{% endcontentbox %}

### 飞跃——动态规划

动态规划（Dynamic Programming）本质是递归递推算法的扩展，~~主要解决多阶段决策问题，~~它有三大基本构成元素——**最优子结构**、**状态转移方程**、**边界条件**。

在上两道题中，我们的函数 $f(x)$ （在代码实现中其实是数组 ``F[]`` ）算是最优子结构，方程 $f(x)=f(x-2)+f(x-1)$ 就是状态转移方程，而 $f(1)=f(2)=1$ 就是递归的边界条件。

至于多阶段决策问题，有几个概念——**状态**、**阶段**、**决策**。如 $f(4)=5$ 被称为一个状态，从 $f(2)=1$ 和 $f(3)=3$ 推到 $f(4)=5$ 的过程被称为阶段，作用在阶段上的选择（本题中还未体现）被称为决策。因此，最优子结构描述状态，边界条件描述初始状态，最终答案描述最终状态，状态转移方程描述决策。

动态规划就是从实际问题中抽象出最优子结构，用状态转移方程依靠边界条件推出中间待求量和最终答案的一个过程。它相较于搜索，排除了每个状态被重复计算的冗余步骤，让每个状态都发挥最大作用。因此，它的状态需要满足**无后效性**和**最优性原理**。无后效性指一个决策至于当前状态有关，而与之前的状态无关，比如数独游戏，之前填过的数之后就不能填了，会影响以后的决策，就没有无后效性；而比如接下来的数字三角形，走到某个坐标后，之前走的路径对之后的决策没有影响，而只有当前坐标会对之后的决策有影响，就满足无后效性。最优性原理是我们能抽象出最优子结构、写出状态转移方程的前提，即整个求最优的问题可以由几个求最优的子问题推出。

但有别于贪心算法目光狭窄的选择，动态规划完全确保考虑到所有情况的转移。

## 数字三角形模型

### T 数字三角形

评测链接：<https://www.acwing.com/problem/content/900/>

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

{% codeblock line_number:false %}
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
{% endcodeblock %}

<br>

这道题我们知道， 每一结点都可以从左上方或右下方的结点移动过来， 那么我们若是用 $F_{i, j}$ 表示从 $(1, 1)$ 到 $(i, j)$ 可以取得的最大数字，那么就有 $F_{i,j}=\max(F_{i-1,j},F_{i-1,j-1})+A_{i,j}$ ，这就是数字三角形问题的状态转移方程，其余的不再赘述。

{% contentbox type:success title:参考代码 %}
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

int n, a[505][505], f[505][505], Ans = -0x7fffffff;

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= i; ++j)
            scanf("%d", &a[i][j]);

    for (int i = 1; i <= n; ++i)
    {
        f[i][1] = f[i - 1][1] + a[i][1];
        f[i][i] = f[i - 1][i - 1] + a[i][i];
        for (int j = 2; j < i; ++j)
            f[i][j] = (f[i - 1][j] > f[i - 1][j - 1] ? f[i - 1][j] : f[i - 1][j - 1]) + a[i][j];
    }

    for (int i = 1; i <= n; ++i)
        Ans = Ans > f[n][i] ? Ans : f[n][i];

    printf("%d", Ans);

    return 0;
}
```
{% endcontentbox %}

### T 摘花生

评测链接：<https://www.acwing.com/problem/content/1017/>

Hello Kitty 想摘点花生送给她喜欢的米老鼠。

她来到一片有网格状道路的矩形花生地（如下图），从西北角进去，东南角出来。

地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。

Hello Kitty 只能向东或向南走，不能向西或向北走。

问 Hello Kitty 最多能够摘到多少颗花生。

{% asset_img pickpeanuts.jpg '"" "摘花生 题图"' %}

<br>

我们显然不能因为这道题是矩形而模型是三角形就宣告模型无效，既然这里可以用矩形和三角形比较，那我们也可以说它们都是几何图形。的确如此，这两道题目都是找一条路线单向向前走，不能回头，一边取得数字，求总和最大。

In that case ，我们可以使用类似数字三角形的思想，用相邻的结点转移出每个结点。具体来讲，如果用 $F_{i, j}$ 表示走到坐标 $(i, j)$ 时的最大坐标，那么就有 $F_{i, j} = \max(F_{i - 1, j}, F_{i, j - 1}) + A_{i, j}$ ，这便是核心。

{% contentbox type:success title:参考代码 %}
```cpp
#include <cstdio>

namespace dft
{
    int r, c, a[105][105], f[105][105];

    int main()
    {
        scanf("%d%d", &r, &c);
        for (int i = 1; i <= r; ++i)
            for (int j = 1; j <= c; ++j)
                scanf("%d", &a[i][j]);

        for (int i = 1; i <= r; ++i)
            for (int j = 1; j <= c; ++j)
                f[i][j] = (f[i - 1][j] > f[i][j - 1] ? f[i - 1][j] : f[i][j - 1]) + a[i][j];

        printf("%d\n", f[r][c]);
        return 0;
    }
}

int T;

int main()
{
    scanf("%d", &T);
    for (int i = 1; i <= T; ++i)
        dft::main();
    return 0;
}
```
{% endcontentbox %}

### T 最低通行费

评测链接：<https://www.acwing.com/problem/content/1020/>

一个商人穿过一个 $N \times N$ 的正方形的网格，去参加一个非常重要的商务活动。

他要从网格的左上角进，右下角出。

每穿越中间 $1$ 个小方格，都要花费 $1$ 个单位时间。

商人必须在 $(2N-1)$ 个单位时间穿越出去。

而在经过中间的每个小方格时，都需要缴纳一定的费用。

这个商人期望在规定时间内用最少费用穿越出去。

请问至少需要多少费用？

注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。

<br>

这道题与摘花生有一定的区别，主要在于没有限制只能向下或向右走，可是由于「商人必须在 $(2N-1)$ 个单位时间穿越出去」， 所以显而易见只能向下或向右走才能满足要求。

那么这道题便与摘花生无异。

略去代码。

### T 方格取数

评测链接：<http://ybt.ssoier.cn:8088/problem_show.php?pid=1287>

设有 $N \times N$ 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字 $0$ 。如下图所示：

{% asset_img number.jpg '"" "方格取数 题图"' %}

某人从图中的左上角 $A$ 出发，可以向下行走，也可以向右行走，直到到达右下角的 $B$ 点。

在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$ ）。

此人从 $A$ 点到 $B$ 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。

<br>

这道题也可以联想到摘花生问题， 对于我们又要重新走回来的棘手问题，这就导致路径具有了后效性，但是我们发现，走过去走回来两阶段的路径，可以通过一些类似于「翻折」的手段，让经过同一方格的情况在单个状态中就被处理掉。

具体来说，我们发现，回时的路也可以看作另一个商人走的去时的路， 那么我们同时移动这两个商人的位置，若是他们走了重叠的方格， 我们就可以在本状态内把它处理掉， 而避免了后效性。

那么，我们可以用 $F_{i1, j1, i2, j2}$ 表示第一个商人走到 $(i1, j1)$ ，第二个商人走到 $(i2, j2)$ 的状态，由于我们是同时移动两者的位置的，所以就会有 $i1 + j1 - 2 = i2 + j2 -2$ ，我们记为 $k$ ，这样，动态规划的最优子结构就降到了三维，即 $F_{k, i1, i2}$ 。对于这个最优子结构，我们照旧地使用状态转移方程，只不过有两点不同：

(1) 需要同时转移两个商人。

(2) 若是转移后到了同一方格， 则应减去重复计算的数值。

这便是核心思想。

{% contentbox type:success title:参考代码 %}
```cpp
#include <cstdio>

template <class T>
T max(T x, T y)
{
    return x > y ? x : y;
}

int u[4][4] = {{-1, 0, -1, 0}, {-1, 0, 0, -1}, {0, -1, -1, 0}, {0, -1, 0, -1}};
int n, x, y, z, a[15][15], f[30][15][15];

int main()
{
    scanf("%d", &n);
    while (scanf("%d%d%d", &x, &y, &z))
    {
        if (!x && !y && !z)
            break;
        a[x][y] = z;
    }

    f[0][1][1] = a[1][1];
    for (int k = 1; k <= (n << 1) - 2; ++k)
    {
        for (int i1 = 1; i1 <= n; ++i1)
        {
            for (int i2 = 1; i2 <= n; ++i2)
            {
                for (int j = 0; j < 4; ++j)
                {
                    if (i1 + u[j][1] && k + 2 - i1 + u[j][2] && i2 + u[j][3] && k + 2 - i2 + u[j][4])
                    {
                        if (i1 == i2)
                            f[k][i1][i2] = max(f[k][i1][i2], f[k - 1][i1 + u[j][1]][i2 + u[j][3]] + a[i1][k + 2 - i1]);
                        else
                            f[k][i1][i2] = max(f[k][i1][i2], f[k - 1][i1 + u[j][1]][i2 + u[j][3]] + a[i1][k + 2 - i1] + a[i2][k + 2 -i2]);
                    }
                }
            }
        }
    }
    printf("%d", f[(n << 1) - 2][n][n]);
    return 0;
}
```
{% endcontentbox %}

### 总结

这几道题，~~与其说是数字三角形模型，还不如是摘花生模型，因为它们都是矩形，~~但是无论叫什么模型，它们与数字三角形的解法思想都是一致的。只要对个别问题的特性有特殊的处理，便能统一到这一类问题上来。

总之，便是一种题目中以「地图」为转移条件的题，直接转化为数学模型便是了。

## 背包问题

背包问题是一类大的问题，一般形式是，容积为 $V$ 的背包， $N$ 件物品，其中第 $i$ 件物品体积（也称费用、重量）为 $v_i$ ，价值为 $w_i$ ，在背包中装入若干件物品，求总价值最大值。

背包问题一般有 0/1 背包、完全背包、多重背包、二维费用的背包问题等。

### T 0/1 背包问题

测评链接：<https://www.acwing.com/problem/content/2/>

有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。第 $i$ 件物品的体积是 $v_i$ ，价值是 $w_i$ 。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

<br>

我们设 $F_{i,j}$ 表示将前 $i$ 件物品中的若干件装入背包，占用不超过 $j$ 的体积，能得到的价值最大值，那么就有状态转移方程
$$
\begin{align}
    F_{i,j}=\max(F_{i-1,j},F_{i-1,j-v_i}+w_i) \nonumber
\end{align}
$$

0/1 背包的空间压缩，称为「滚动数组」的优化技巧，要求内层从 $v$ 到 $1$ 循环。

{% contentbox type:success title:参考代码 %}
```cpp
#include <cstdio>

int n, v, c, w, f[1005];

int main()
{
    scanf("%d%d", &n, &v);
    for (int i = 1; i<= n; ++i)
    {
        scanf("%d%d", &c, &w);
        for (int j = v; j >= 1; --j)
        {
            if (j < c) f[j] = f[j];
            else
                f[j] = f[j - c] + w > f[j] ? f[j - c] + w : f[j];
        }
    }

    printf("%d", f[v]);

    return 0;
}
```
{% endcontentbox %}

### T 完全背包问题

测评链接：<https://www.acwing.com/problem/content/3/>

有 $N$ 种物品和一个容量是 $V$ 的背包，每种物品都有无限件可用。第 $i$ 种物品的体积是 $v_i$ ，价值是 $w_i$ 。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

<br>

我们设 $F_{i,j}$ 表示将前 $i$ 件物品中的若干件装入背包，占用不超过 $j$ 的体积，能得到的价值最大值，那么就有状态转移方程
$$
\begin{align}
    F_{i,j}= \max \\{ F_{i-1,j-k \cdot v_i}+k \cdot w_i \  | \  k \in \mathbb{N} \land k \cdot v_i \le j \\} \nonumber
\end{align}
$$
完全背包的空间压缩有一个技巧，只需要将 0/1 背包的内层循环顺序改为从 $1$ 到 $v$ 循环，即可实现 0/1 背包到完全背包的转换，恰好也优化了时间，避免了三层循环。因为 0/1 背包需要保证从上一次外层循环的子结构转移而来，而完全背包从本次外层循环的子结构转移恰好满足取多个物品的要求。

{% contentbox type:success title:参考代码 %}
```cpp
#include <cstdio>


int n, v, c, w, f[1005];

int main()
{
    scanf("%d%d", &n, &v);
    for (int i = 1; i<= n; ++i)
    {
        scanf("%d%d", &c, &w);
        for (int j = 1; j <= v; ++j)
        {
            if (j < c) f[j] = f[j];
            else
                f[j] = f[j - c] + w > f[j] ? f[j - c] + w : f[j];
        }
    }

    printf("%d", f[v]);

    return 0;
}
```
{% endcontentbox %}

### T 多重背包问题

有 $N$ 种物品和一个容量是 $V$ 的背包。第 $i$ 种物品最多有 $s_i$ 件，每件体积是 $v_i$ ，价值是 $w_i$ 。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。

输出最大价值。

<br>

多重背包一般拆分成 0/1 背包解决，因此也设 $F_{i,j}$ 表示将前 $i$ 件物品中的若干件装入背包，占用不超过 $j$ 的体积，能得到的价值最大值。

#### 直接拆分法

评测链接：<https://www.acwing.com/problem/content/4/>

加入第三层循环，遍历当前物品取多少个，则有状态转移方程
$$
\begin{align}
    F_{i,j}= \max \\{ F_{i-1,j-k \cdot v_i}+k \cdot w_i \  | \  k \in \mathbb{N} \land k \cdot v_i \le j \land k \le s_i \\} \nonumber
\end{align}
$$

{% contentbox type:success title:参考代码 %}
```cpp
#include <cstdio>

template <class T>
T max(T x, T y)
{
    return x > y ? x : y;
}

int N, V, s[105], v[105], w[105], f[105];

int main()
{
    scanf("%d%d", &N, &V);
    for (int i = 1; i <= N; ++i)
        scanf("%d%d%d", v + i, w + i, s + i);
    for (int i = 1; i <= N; ++i)
    {
        for (int j = V; j >= 0; --j)
        {
            for (int k = 0; k * v[i] <= j && k <= s[i]; ++k)
            {
                f[j] = max(f[j], f[j - k * v[i]] + k * w[i]);
            }
        }
    }

    printf("%d", f[V]);

    return 0;
}
```
{% endcontentbox %}

#### 二进制拆分法

评测链接：<https://www.acwing.com/problem/content/5/>

任意正整数可以拆分为若干 $2$ 的不同次幂的和，且 $2$ 从 $0$ 次方开始的连续次幂可以组合出从 $1$ 开始的连续正整数。

而为了让拆分出的数任意组合能组合出 $1$ 到 $s_i$ 的所有整数而不超过 $s_i$ ，我们将 $s_i$ 拆分成
$$
\begin{align}
    \sum\limits_{i=0}^{\left\lfloor\log_2(s_i+1)-1\right\rfloor}2^i+r_i
\end{align}
$$
$r_i$ 是根据具体拆分的余数。

这样的二进制拆分虽然有重复计算，但相较于直接拆分还是快得多了。因为直接拆分法虽然也只是遍历了从 $1$ 到 $i$ 的每种情况，但相当于是二进制拆分法通过搜索式的组合而来的。自然，动态规划的转移比搜索的组合快得多了。

在具体实现时，我们只需要将拆分出的物品依次加入 ``vector`` 或是另一个数组中。

#### 单调队列优化

见[动态规划 - 单调队列优化](/Informatics/Notes/DYNAMIC-PROGRAMMING-Monotonic-Queue-Optimization/)。

### T 二维费用的背包问题

测评链接：<https://www.acwing.com/problem/content/8/>

有 $N$ 件物品和一个容量是 $V$ 的背包，背包能承受的最大重量是 $M$。每件物品只能用一次。体积是 $v_i$ ，重量是 $m_i$ ，价值是 $w_i$ 。求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。输出最大价值。

<br>

与 0/1 背包无异，我们设 $F_{i,j,k}$ 表示将前 $i$ 件物品中的若干件装入背包，占用不超过 $j$ 的体积，不超过 $k$ 的重量，能得到的价值最大值，那么就有状态转移方程
$$
\begin{align}
    F_{i,j,k}=\max(F_{i-1,j,k},F_{i-1,j-v_i,k-m_i}+w_i) \nonumber
\end{align}
$$

### 分组背包问题

有 $N$ 组物品和一个容量是 $V$ 的背包。每组物品有若干个，同一组内的物品最多只能选一个。

每件物品的体积是 $v_{i,j}$ ，价值是 $w_{i,j} $，其中 $i$ 是组号，$j$ 是组内编号。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。

<br>

将同一组的物品打包，额外进行内部决策，决策出每一组的最优子结构。剩下部分用普通的背包问题解决，时间复杂度为 $\mathrm{O}(n^3)$。

### 有依赖的背包问题

见树形动态规划。

### 总结

背包问题的模型都万变不离其宗，很容易可以转化出背包问题的一般模型——在限制中进行取与不取的策略组合，尽量拿到最大价值。

背包问题中，基本上都用线性动态规划解决，只有有依赖的背包问题用了树状动态规划~~（其实只是顶个名头）~~。物品的的两个属性——费用与价值的对立，人生的两个属性——现实与欲望的对立，让我们不得不在物品中做出取舍，在背包承受的范围内，尽量满足人性的欲望。

而在 OIer 看来，对于各个物品的分阶段决策，我们只需要保留对下一阶段决策有意义的数据，在本该有的决策集合中做出取舍，避免无效的时间浪费，这是否也是一种背包思维呢？

人生远不是功利与代价所支配的一场闹剧，切勿为身外之物困扰。生活远不是背包问题所代表的费用与价值二者对立，或许存在更有意义的事物值得我们去追求。

## 总结

线性动态规划是建立对动态规划认识的第一步，这里我们掌握动态规划的主要思想，为将来的区间动态规划、树形动态规划等打基础。

线性是时间的永恒主题，在茫然与徘徊中心灵最终也会有历史的归属，阶段的转移，我们会当迈向不远的未来。

让历史告诉未来，让时间见证青春。
