---
title: 图论 - 强连通分量
tags:
  - '图论'
categories:
  - Informatics
  - Notes
date: 2022-10-14 22:19:38
---


回眸，眼里绽放的是双向奔赴的美好

<!--more-->

## 定义

在有向图中，我们称两点 $u,v$ 强连通，当且仅当存在一条路径从 $u$ 到 $v$ 和一条路径从 $v$ 到 $u$。显然，强连通具有传递性。有向图的强连通分量，指的是有向图的极大强连通子图。

## Tarjan 算法

~~啊，怎么又是你。~~

### DFS 生成树

我们按照 DFS 过程中结点的扩展关系，建立一棵 DFS 生成树，或者是生成森林。

{% asset_img dfs-tree.svg '"" "DFS 生成树 图示"' %}

有向图的 DFS 生成树中存在四种边：

  1. 树边：树边为 DFS 过程中有效扩展了结点的边，存在于 DFS 生成树种。
  2. 反祖边：如图中边 $(7,1)$，从后代指向祖先的边。
  3. 横叉边：如图中边 $(9,7)$，连接两个不存在祖先后代关系的结点的边。
  4. 前向边：如图中边 $(3,6)$，从祖先指向非儿子后代的边。

关于 DFS 生成树的横叉边，我们可以发现一定是从后访问的结点指向先访问的结点，否则这条边将作为树边存在。

### Tarjan 算法

我们可以发现，DFS 生成树的树边代表了一个方向的「连通」，而另一个方向的「连通」则依赖于反祖边存在。横叉边先且不讨论，（前向边完全就是没用的）。

如果从一个结点出发存在一条反祖边，显而易见，从这条边连接的祖先到这个结点之间的所有节点都应存在于一个强连通分量内部，但并不能保证这个强连通分量只包含这些结点。事实上，我们的强连通分量应该是由若干反祖边与树边组成的环交叉构成的，就像这样。

{% asset_img interlocking.png '"" "强连通分量 环环相扣"' %}

在上图中，我们 $1,2,3,4$ 四个结点应该属于同一个强连通分量。

于是，我们考虑用一个值 $ret_x$ 表示结点 $x$ 及其后代能够通过反祖边直接返回的最早祖先。$ret_x=x$ 时表示结点 $x$ 是其所在强连通分量中访问最早的一个结点，而 $ret_x\neq x$ 表示结点 $x$ 与其父亲属于同一个强连通分量。

接下来考虑横叉边，如果横叉边连接的两个结点属于同一个强连通分量，假设横叉边为 $(v,u)$，那么从 $u$ 到 $v$ 的路径一定经过其最近公共祖先，否则会存在另一条横叉边 $(u,v)$，而我们上面说过这样的横叉边是不会存在的。那么，如果 $u$ 和 $v$ 同属于一个强连通分量，那么 $u,v$ 及其最近祖先均属于同一个强连通分量。

为了能够快速地判断横叉边，我们可以选择在 DFS 回溯的时候将同属于一个强连通分量的后代结点并入祖先结点。当然这样说是不准确的，因为我们在回溯过程中尚未能最终确定一个结点所处的强连通分量中最早访问的结点，因此开一个数组来存储是不现实的。

我们的做法是，在 DFS 中给每个结点打上一个时间戳（DFS 序）。同时开一个栈，栈内存储的元素为当前结点的祖先及其同强连通分量的结点，并且我们能够保证同一强连通分量的结点均相邻。这样，栈里存储的结点均为可以到达当前结点的结点，此时我们如果扫描到一条反祖边或横叉边，其指向栈内结点，那么此两者就应同属于一个强连通分量，此时应该用指向结点的时间戳更新 $ret_x$。

对栈的操作是，在 DFS 过程中，每访问一个结点即压栈，每退出一个 $ret_x=x$ 的结点，在栈中从该结点往上的所有结点构成一个强连通分量，弹出这些结点。

## T 强连通分量 2

题目来源：124OJ 828
评测链接 1：<http://124.221.194.184/problem/828>
评测链接 2：<https://hydro.ac/d/sukwoj/p/QZ828>

求强连通分量，并输出每个强连通分量。

{% contentbox type:success title:参考代码 %}
```cpp
#include <cstdio>

const int MAXN = 10000, MAXM = 500000;

int n, m;
int h[MAXN + 5], to[MAXM + 5], nxt[MAXM + 5];

int ans = 0, Ans_nxt[MAXN + 5], sz[MAXN + 5];

int dfn[MAXN + 5], tot = 0, bak[MAXN + 5];
bool in_stk[MAXN + 5];
int stk[MAXN + 5], top = 0;

void Tarjan(int x)
{
    dfn[x] = ++tot;
    in_stk[stk[++top] = x] = true;
    bak[x] = x;
    for (int i = h[x]; i; i = nxt[i])
    {
        if (!dfn[to[i]])
        {
            Tarjan(to[i]);
            bak[x] = dfn[bak[to[i]]] < dfn[bak[x]] ? bak[to[i]] : bak[x];
        }
        else if (in_stk[to[i]]) bak[x] = dfn[to[i]] < dfn[bak[x]] ? to[i] : bak[x];
    }
    if (bak[x] == x)
    {
        ans++;
        while (stk[top] != x)
        {
            sz[x]++;
            Ans_nxt[stk[top]] = Ans_nxt[x];
            Ans_nxt[x] = stk[top];
            in_stk[stk[top--]] = false;
        }
        sz[x]++;
        in_stk[stk[top--]] = false;
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        to[i] = v;
        nxt[i] = h[u];
        h[u] = i;
    }

    for (int i = 1; i <= n; i++) if (!dfn[i]) Tarjan(i);
    
    printf("%d\n", ans);
    for (int i = 1; i <= n; i++)
    {
        if (bak[i] == i)
        {
            printf("%d ", sz[i]);
            for (int j = i; j; j = Ans_nxt[j]) printf("%d ", j);
            puts("");
        }
    }

    return 0;
}
```
{% endcontentbox %}

## Kosaraju 算法

Kosaraju 算法是这样描述的，首先 DFS 整张图，在扩展完结点后计入 DFS 序（后序遍历）。然后从 DFS 序中最后一个未被访问的结点出发，沿反向边搜索，如果搜到的点未被访问过，那么就将其加入这个强连通分量，然后标记为已访问。两次 DFS 过后即找到所有强连通分量。

正确性显然。对于当前最后一个结点，其能够到达的结点都在 DFS 序中的前方，而其前方不能够到达的结点也不能够到达它，因此往前搜能够到达自己的结点一定与自己属于同一强连通分量。

代码略。

## 总结

我沿着留下的痕迹找到你，你越过遥远的过去守望我。

一次寻觅，一次回眸，是一场美丽的双向奔赴。
