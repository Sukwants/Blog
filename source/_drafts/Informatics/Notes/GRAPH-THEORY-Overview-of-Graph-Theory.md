---
title: 图论 - 图论概述
tags:
  - '[I] 图论'
categories:
  - Informatics
  - Notes
date: 2022-08-02 15:27:06
---


图论论图

<!--more-->

## 图论概述

图论，顾名思义，论图者也。

图论是以图为研究对象的理论，数学的一个分支。

{% pdf /Informatics/Notes/GRAPH-THEORY-Overview-of-Graph-Theory/graphtheory-wiki-zh-cn.pdf %}

## 图的概念

**图**的形式化定义是有序对 $G=(V,E)$，其中 $V$ 是点集，包含的元素称为**结点**，$E\subseteq \\{(x,y)\ |\ x\in V,y\in V\\}$ 是连接 $V$ 中两点的边集，包含的元素被称为**边**。

通俗来讲，我们有一些点，然后有一些边将这些点连接起来，点的位置、边的长度和方向均无意义，这样的点与边的集合我们称为图。

有时候边有方向，我们通过这个边只能从一个端点到另一个端点，这样的图称为**有向图**（下图右），有向图的边被称为**有向边**或者**弧**，有向边有**起点**和**终点**之分。另外一些时候，我们通过边可以任意往返，这样的图称为**无向图**（下图左），无向图的边被称为**无向边**。

一般的图是这个样子的。

{% asset_img graph1.png '"" "图 1"' %}

当然，如果你愿意，也可以有这样的图。

{% asset_img graph2.png '"" "图 2"' %}

还有来自图论与几何拓扑学创立之时的七桥问题。

{% asset_img graph3-7bridges.png '"" "图 3 - 七桥问题"' %}

也可以把梅涅劳斯的图形看成是图。

{% asset_img graph4-mathematics.png '"" "图 4 - 数学相关"' %}

或者说，基尔霍夫研究的玩意儿。

{% asset_img graph5-physics.png '"" "图 5 - 物理学相关"' %}

事实上这些也可以视为是图。

{% asset_img graph6-chemistry.png '"" "图 5 - 化学相关"' %}

言归正传，这就是图。

在无向图中，一个结点的**度**定义为以之作为端点的边的数量。在有向图中，一个结点的**入度**定义为以之作为终点的边的数量，**出度**定义为以之作为起点的边的数量。

**自环**指的是连接一个结点自己和自己的边。

**重边**指的是相同的两条边。

**简单图**指的是没有自环和重边的图，否则被称为**多重图**。

**途径**指的是若干条首尾相连的边的序列。

**迹**指的是不包含重复的边的途径。

**路径**指的是不经过重复的点的迹。

**回路**指的是起点和终点相同的迹。

**环 / 圈**指的是除起点和终点相同以外再无重复的点的回路。

有时，途径 / 路径、回路 / 环的概念会混用。

有图 $G=(V,E)$，若存在图 $H=(V',E')$，且满足 $V'\subseteq V,E'\subseteq E$，则称 $H$ 是 $G$ 的子图，记作 $H\subseteq G$。

在无向图中，两个结点**连通**，当且仅当这两个节点之间有路径直接或间接相连。无向图**连通**，指无向图中任意两点均连通。无向图的**连通分量**定义为无向图的极大连通子图（极大，并非最大，指不是任何原图的连通子图的子图）。

在有向图中，从结点 $u$ 可达结点 $v$，当且仅当有一条路径从 $u$ 到 $v$。有向图**强连通**，指有向图中任意两点均相互可达。有向图的**强连通分量**定义为有向图的极大强联通子图。有向图弱连通，指将所有边替换为无向边后图是连通的。有相同的弱连通分量定义为有向图的极大弱连通子图。

无向图是**完全图**，当且仅当任意两点之间均存在边。有向图是**完全图**，当且仅当任意两点之间均存在双向边。

令边的数量为 $M$，点的数量为 $N$。当 $M$ 与 $N^2$ 同级时，图被称为**稠密图**。当 $M$ 与 $N$ 同级时，图被称为**稀疏图**。

## 图的存储

### 直接存边

开一个数组来存每条边的对应信息，适用于只需要按边进行操作的情况，尤其是需要对边进行排序的情况，比如 Kruskal 算法。

显著优点是可以直接按边进行操作。

显著缺点是每次按结点查询边的操作都需要 $\mathrm{O}(m)$ 的时间复杂度。

### 邻接矩阵

使用 ``adj[u][v]`` 记录从点 ``u`` 到点 ``v`` 的边，存储是否存在的信息或者边的权值。适用于无重边的情况。

显著优点是可以 $\mathrm{O}(1)$ 查询指定起点和终点的边。

显著缺点是空间复杂度 $\mathrm{O}(n^2)$，容易 <font style="color:orange"><i class="fa-solid fa-microchip"></i> Memory Limit Exceeded</font>。

另外，查询以指定结点为起点或终点的边，时间复杂度为 $\mathrm{O}(n)$。

### 邻接表

对于每个结点开一个数组或者链表记录边的信息。

#### vector 实现

这是一般意义上的邻接表，对每个结点开一个 ``vector`` 记录以之为起点的边的信息。

#### 链表实现

又被称为「链式前向星」，一般用数组模拟链表实现邻接表，也可以看成在直接存边的基础上增加了限制条件和存储信息。

整体来看，是将所有边的信息用数组存储下来，并且不能随意排序。开一个 ``h[MAXN]``，记录每个结点的链表的第一条边的编号。很明显，每一条边都只会属于一条链表，因此，开一个 ``nxt[MAXM]`` 记录链表中，每一条边的下一条边的编号。

建边的操作是，将新加入的边加到链表的头部，即 ``nxt[++cnt]=h[x]; h[x]=nxt[cnt];``。

## 图的遍历

有 DFS 和 BFS。

DFS 从一个结点开始，标记为已访问，随即对能直接到达的所有未访问的结点进行 DFS。

DFS 序指的是 DFS 过程中访问结点的序列。

BFS 将任一结点标记为已访问，加入队列。每次取出队首结点，将能直接到达的所有未访问的结点标记为已访问，并加入队列。直至队列为空。

显而易见，若所有边的权值都视为 $1$，因为我们每次会将所有同样路径长度的终点访问完，才开始访问下一长度的路径终点，那么 BFS 过程中每到达一个结点，一定是通过最短路到达的。

BFS 序指的是 BFS 过程中访问结点的序列。

