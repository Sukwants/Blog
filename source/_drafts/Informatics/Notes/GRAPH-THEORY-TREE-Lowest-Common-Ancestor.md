---
title: 图论 - 树 - 最近公共祖先
tags:
  - '[I] 图论'
  - '[I] 树'
categories:
  - Informatics
  - Notes
date: 2022-08-05 15:18:05
---


沿着时间之线追溯遥远的血缘

<!--more-->

## 问题

知一棵树之族，问两结点来自远古的血脉自何时始分化。

抑或言之，求树上两个结点的公共祖先中深度最深的那一个。

这是最近公共祖先（Lowest Common Ancestor, LCA）问题。

朴素算法是，首先将深度较深的结点跳到它的一个祖先，让其与另一个结点深度相同。然后不停对两个结点找父亲，直到两个结点相同，即找到了最近公共祖先。无疑，很容易 TLE。

当然，我们这里讨论的是对同一棵树多次询问，如果是单次询问的话那么朴素算法就是最快的。

## 倍增法

我们对结点一层一层地跳，那么就很容易被卡到 $\mathrm{O}(n)$，此时我们思考，是否可以一次性跳过很多层，来迅速略过祖先不同的时期，并且也要不至于找到非最深的公共祖先。具体要跳多少层我们并不清楚，但我们可以判断出跳过去是否超过了应该直接略过的层数，也就是如果我们跳过去过后两个结点相同了，那么就是超过。根据每个正整数都可以分解为若干个 $2$ 的幂之和的性质，我们可以每次跳过 $2$ 的幂层，这样时间即使被卡也被减少到了 $\mathrm{O}(\log n)$。即每次找最大可以跳的也就是跳过去不会相同的 $2$ 的幂层，直到两结点的父亲相同时为止。

我们预处理出一个空间复杂度为 $\mathrm{O}(n\log k)$ 的数组 $f_{i,j}$，指向结点 $i$ 的 $j$ 代祖先。预处理时间复杂度为 $\mathrm{O}(n\log k)$，因此单次询问就不要用倍增法了。

$$
\\begin{array}{ll}
  \\begin{array}{l}
    \\text{PRESET}(x) \\\\
    \\begin{array}{ll}
      1 &  f_{x,0} \\gets fa_x \\\\
      2 &  i \\gets 0 \\\\
      3 &  \\textbf{while } f_{x,i} \\neq 0 \\\\
      4 &  \\qquad i \\gets i + 1 \\\\
      5 &  \\qquad f_{x,i} \\gets f_{f_{x,i-1},i-1} \\\\
      6 &  \\textbf{for } y \\in S_x \\\\
      7 &  \\qquad \\text{PRESET}(y)
    \\end{array}
  \\end{array}
  &  \\begin{array}{l}
    \\text{LCA}(x,y) \\\\    \\begin{array}{ll}
      1  &  \\textbf{if } d_x < d_y \\\\
      2  &  \\qquad \\text{SWAP}(x,y) \\\\
      3  &  \\textbf{while } d_x < d_y \\\\
      4  &  \\qquad x \\gets f_{x,2^{\\lfloor \\log_2(d_x-d_y) \\rfloor}} \\\\
      5  &  \\textbf{while } fa_x \\neq fa_y \\\\
      6  &  \\qquad i \\gets 0 \\\\
      7  &  \\qquad \\textbf{while } f_{x,i} \\neq f_{y,i} \\\\
      8  &  \\qquad \\qquad i \\gets i + 1 \\\\
      9  &  \\qquad x \\gets f_{x,i-1} \\\\
      10 &  \\qquad y \\gets f_{y,i-1} \\\\
      11 &  \\textbf{return } fa_x
    \\end{array}
  \\end{array}
\\end{array}
$$

## Tarjan

解决 LCA 的 Tarjan 算法是伟大的计算机科学家 Tarjan 发明的离线算法。

大致思路是，通过 DFS 和并查集。在每搜完以结点 $x$ 为根的子树后，先扫描与 $x$ 有关的询问 $(x,y)$，如果 $y$ 已经被搜到过，那么并查集的 $f_y$ 即为该询问的答案，记录下来。再将以 $x$ 为根的子树并入以 $x$ 的父结点为根的子树的并查集。

正确性在于，首先我们需要明确，如果能够处理询问 $(x,y)$，那么结点 $y$ 已经被搜到过，$x$ 恰好搜完。

此时，如果结点 $y$ 是结点 $x$ 的后代，那么 $f_y$ 就指向 $x$，答案正确。

如果结点 $y$ 非结点 $x$ 的后代，那么 $f_y$ 表示的是，包含结点 $y$ 的极大已搜完子树，其父亲节点的编号。因为包含结点 $y$ 的极大已搜完子树并不会包含结点 $x$，并且以其父亲节点为根的子树尚未搜完，说明结点 $x$ 不被包含在这棵极大子树内而被包含在以 $f_y$ 为根的子树内，那么答案即为 $f_y$。

## 欧拉序列上的 RMQ 问题

欧拉序列指的是，对于每棵子树，首先访问根结点，接着每访问完一棵子树，就再访问一次根结点，所生成的序列。

此时可以发现，访问同一结点下的不同子树的两个结点之间，会访问一次根结点；而访问同一结点下的同一子树的两个结点之间，并不会访问根结点。于是，我们对于询问 $(x,y)$，要求的就是在访问 $x,y$ 之间，所访问的最低深度的结点。打一个 ST 表完事。

## 总结

世界问，你是谁，来自哪？请回答。

爱什么，梦什么，去何方？请回答。

答案有，一百年的时光。

源自血脉分化之时的亲缘或已无迹可寻，取自民族的信念依旧强盛。无论最近公共祖先已经消散在了多少年前的历史尘埃之中，血液中依旧流淌着古老的民族自强不息的强大活力。
